var tipuesearch = {"pages":[{"text":"quarantine","tags":"home","loc":"index.html","title":" quarantine "},{"text":"This file depends on sourcefile~~read_write_basic_mod.f90~~EfferentGraph sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~read_write_basic_mod.f90~~AfferentGraph sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Read_Write_Basic_Mod Source Code Read_Write_Basic_Mod.f90 Source Code Module Read_Write_Basic_Mod ! !********************************************************************************************************************************** ! This module defines the raw reads/writes of derived data types to/from a data file.  The access can be ASCII or Binary with the default being Binary. !     This module contains 1D through 7D routines but can define array data types to 15D, the 2008 Standard (Intel allows 31D, PGI is unknown). !     This module can handle any derived data type to be read/written to a file.  Just add the derived data type and a corresponding Read_<type> and Write_<type> !     subrotuine to the module.  Make it provate and it cannot be intercepted by any other routine Use'ing this module !********************************************************************************************************************************** ! Use Parameters_Mod ! !********************************************************************************************************************************** ! No implicit typing !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! All names are private except as noted below !********************************************************************************************************************************** ! Private ! !********************************************************************************************************************************** ! Make public only the subroutine names and the data types !********************************************************************************************************************************** ! Public :: Read_Data ! !********************************************************************************************************************************** ! The subrotines are define below.  The Read_Data and Write_Data subroutines are all that are public.  All other routines are private !********************************************************************************************************************************** ! Contains ! !================================================================================================================================== ! Read Data - Public !================================================================================================================================== ! Subroutine Read_Data ( FILE , Data_up , ACCESS , OBytes , Opt_Int , Quite ) ! !********************************************************************************************************************************** ! This routine reads data into the data type passed by Data_up and passes it back to the calling routine. !       The data type is queried below and the proper set of reads are used. !       Any data type can be read with this routine. !********************************************************************************************************************************** ! Use needed modules for data definitions !********************************************************************************************************************************** ! Use Type_CArray_1D_Mod Use Type_Target_Material_Mod ! !********************************************************************************************************************************** ! No implicit data typing !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! Data_up - An unlimited polymorphic Pointer that points to the data straucture to be read ! FILE - The file name to open and connect to the LU ! ACCESS - Optional value of BIN or ASC to open the file formatted ro unformatted manually. !               The default is in the global variable G_Binary ! OBytes - Optional output for the output number of bytes read ! Opt_Int - Optional Integer to pass to type routine ! Quite - Optional Integer argument to not have data read output if defined, value unimportant !********************************************************************************************************************************** ! Class ( * ), Pointer , intent ( in ) :: Data_up Character ( Len =* ), intent ( in ) :: FILE Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS Integer , Optional , intent ( out ) :: OBytes Integer , Optional , intent ( inout ) :: Opt_Int Integer , Optional , intent ( in ) :: Quite ! !********************************************************************************************************************************** ! Local variables !   i - do loop index !   LU - The Logical Unit number to read !   IOSTAT - Message buffer from IO errors !   NOBytes - The function to determine BYTES read !   IOMSG - Message buffer from memory managment errors !   NAM - Return from Inquire Function that contains the name of the opened data file !   FORM - The string used to open the file formatted or unformatted !   Binary - Flag for Binary (unformatted - true) or ASCII (formatted - false) data access !   OPENED - Flag for opened data file or not from the Inquire function !   RW - Flag to determine if reading or writting to Output_Bytes !********************************************************************************************************************************** ! Integer :: i , LU , IOSTAT Integer :: NOBytes Character ( LEN = IOMSG_SIZE ) :: IOMSG Character ( LEN = CLEN_SIZE ) :: NAM Character ( LEN = 11 ) :: FORM Logical :: Speak , Binary , OPENED , RW = . true . ! !********************************************************************************************************************************** ! Determine if Quite is defined !********************************************************************************************************************************** ! Speak = . true . Q : If ( Present ( Quite ) ) Then Speak = . false . End If Q ! !********************************************************************************************************************************** ! Determine access for file open (formatted or unformatted) !********************************************************************************************************************************** ! DACif : If ( . not . Present ( ACCESS ) ) Then Binary = G_BINARY BINIf : If ( Binary ) Then FORM = 'unformatted' Else FORM = 'formatted' End If BINIf Else ACif : If ( ACCESS ( 1 : 3 ) . eq . 'BIN' ) Then FORM = 'unformatted' ; Binary = . true . Else If ( ACCESS ( 1 : 3 ) . eq . 'ASC' ) Then FORM = 'formatted' ; Binary = . false . Else Write ( * , * ) 'Optional ACCESS present does not equal \"BIN\" or \"ASC\"' Write ( * , * ) 'ACCESS = ' , ACCESS ( 1 : 3 ) Stop 'Abort Read_Data' End If ACif End If DACif ! !********************************************************************************************************************************** ! Open the data file for read !********************************************************************************************************************************** ! Open ( newunit = LU , file = trim ( FILE ), status = 'old' , form = trim ( FORM ), action = 'read' , iostat = IOSTAT , iomsg = IOMSG ) OPerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'File Open Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Data' End If OPerr ! !********************************************************************************************************************************** ! Select code execution on the data type being read !********************************************************************************************************************************** ! DUPtyp : Select Type ( Data_up ) ! !********************************************************************************************************************************** ! Type: CArray_1D - read data and tell user how many bytes read !********************************************************************************************************************************** ! Type is ( CArray_1D ) ! Call Read_CArray_1D ( LU , Binary , Data_up ) Q_C1D : If ( Speak ) Then WObytes_C1D : If ( present ( OBytes ) ) Then !                        OBytes = Output_Bytes ( RW, FILE, Binary, Data_up%Dimen, Data_up%lower_p, Data_up%upper_p ) OBytes = Output_Bytes ( RW , FILE , Binary , Data_up % Dimen , Data_up % lower , Data_up % upper ) Else !                        NObytes = Output_Bytes ( RW, FILE, Binary, Data_up%Dimen, Data_up%lower_p, Data_up%upper_p ) NObytes = Output_Bytes ( RW , FILE , Binary , Data_up % Dimen , Data_up % lower , Data_up % upper ) End If WOBytes_C1D End If Q_C1D print * , 'Read_Write_Basic_Mod: Data_up%upper(1) = ' , Data_up % upper ( 1 ) do i = 1 , Data_up % upper ( 1 ) print * , '                      Data_up%Data(i)  = ' , i , trim ( Data_up % Data ( i )) enddo ! !********************************************************************************************************************************** ! Type Target_Material - read data !********************************************************************************************************************************** ! Type is ( Target_Material_Pointer ) ! Call Read_Target_Material ( LU , Binary , Data_up ) Q_Targ : If ( Speak ) Then Write ( * , * ) 'Read ' , trim ( FILE ), ' - no size data available' End If Q_Targ ! ! !********************************************************************************************************************************** ! Class Default - Error out !********************************************************************************************************************************** ! Class Default ! Write ( * , '(a,i0,1x,a)' ) 'The class of the data passed to Read_Data was not recognized' Stop 'Abort Read_Data' ! !********************************************************************************************************************************** ! End Select Type on Data_up !********************************************************************************************************************************** ! End Select DUPTyp ! !********************************************************************************************************************************** ! Close the Data File !********************************************************************************************************************************** ! Close ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) CLerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'File Close Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Data' End If CLerr ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of Subroutine Read_Data !********************************************************************************************************************************** ! End Subroutine Read_Data ! !================================================================================================================================== ! Routine to write out the number of Bytes read/written - Private !================================================================================================================================== ! Function Output_Bytes ( Read_flag , FILE , Binary , Dimen , lower , upper ) Result ( OBytes ) ! !********************************************************************************************************************************** ! No implicit typing !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! FILE - The file name just read/written ! Read_Flag - .true. if reading; .false. if writting ! Binary - .true if binary and .false. if ASCII ! Dimen - The dimension of the array being read/written ! lower - The lower bounds of the array indicies ! upper - The upper bounds of the array indicies ! OBytes - The number of BYTES read/written to/from a file (needs to be I*8) !********************************************************************************************************************************** ! Character ( Len =* ), intent ( in ) :: FILE Logical , intent ( in ) :: Read_Flag , Binary Integer , intent ( in ) :: Dimen , lower ( 1 : Dimen ), upper ( 1 : Dimen ) Integer :: OBytes ! !********************************************************************************************************************************** ! Local Varaibles !   Data_size - The size in B/kB/MB/GB/TB of the data !   unit - The unit used in the write statement !   punit - The possible sizes allowed !   i - Do loop index !********************************************************************************************************************************** ! Real :: Data_size Character ( Len = 2 ) :: unit , punit ( 5 ) = [ 'B ' , 'kB' , 'MB' , 'GB' , 'TB' ] Integer :: i ! !********************************************************************************************************************************** ! Determine the size in Bytes of a binary data file !********************************************************************************************************************************** ! IFBin : If ( Binary ) Then Data_size = 1.0d0 DoBsize : Do i = 1 , Dimen Data_size = Data_size * ( upper ( i ) - lower ( i ) + 1 ) End Do DoBSize Data_size = Data_size * kind ( Data_size ) Data_size = Data_size + ( 2 * Dimen * kind ( upper ( 1 )) ) ! !********************************************************************************************************************************** ! Determine the size in Bytes of an ASCII data file !********************************************************************************************************************************** ! Else Data_size = 1.0d0 DoAsize : Do i = 1 , Dimen Data_size = Data_size * ( upper ( i ) - lower ( i ) + 1 ) End Do DoASize Data_size = Data_size * ASCII_DATA_SIZE Data_size = Data_size + ( 2 * Dimen * ASCII_BOUND_SIZE ) ! !********************************************************************************************************************************** ! End of IF block on data size determination !********************************************************************************************************************************** ! End If IFBin ! !********************************************************************************************************************************** ! Set the function result to an integer of size - use default fortran 2003 conversion !   This is in BYTES !********************************************************************************************************************************** ! OBytes = Int ( Data_size ) ! !********************************************************************************************************************************** ! Find the 1024 byte scale that brings the size between >=1 and <1024 then set unit to the two letter code for the scale factor !********************************************************************************************************************************** ! unit = 'ER' Dounit : Do i = 1 , 5 If ( Data_size . ge . 1.0d0 . and . Data_size . lt . 102 4.0d0 ) Then unit = punit ( i ) exit End If Data_size = Data_size / 102 4.0d0 End Do Dounit ! !********************************************************************************************************************************** ! Tell the user - whether a read or write !********************************************************************************************************************************** ! IfRDF : If ( Read_flag ) Then Write ( * , '(1x,f14.7,1x,a2,a,a)' ) Data_size , unit , ' read from ' , trim ( FILE ) Else Write ( * , '(1x,f14.7,1x,a2,a,a)' ) Data_size , unit , ' written to ' , trim ( FILE ) End If IfRDF ! !********************************************************************************************************************************** ! Return to calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of function Output_Bytes !********************************************************************************************************************************** ! End Function Output_Bytes ! End Module Read_Write_Basic_Mod","tags":"","loc":"sourcefile/read_write_basic_mod.f90.html","title":"Read_Write_Basic_Mod.f90 – quarantine"},{"text":"This file depends on sourcefile~~read_write_trninput_mod.f90~~EfferentGraph sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 var pansourcefileread_write_trninput_modf90EfferentGraph = svgPanZoom('#sourcefileread_write_trninput_modf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~read_write_trninput_mod.f90~~AfferentGraph sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Read_Write_TRNINPUT_Mod Source Code Read_Write_TRNINPUT_Mod.f90 Source Code Module Read_Write_TRNINPUT_Mod ! Use Parameters_Mod ! ! No explicit typing Implicit None ! ! Make all names private Private ! ! Make these Subroutine names Public Public :: Read_TRNINPUT ! Contains ! Subroutine Read_TRNINPUT ( FILE , u , C , ACCESS , Quite ) ! Use Read_Write_Basic_Mod , only : Read_Data Use Type_CArray_1D_Mod , only : CArray_1D ! Implicit None ! Integer , Target , intent ( out ) :: u Character ( LEN = CLEN_SIZE ), Target , Allocatable , Dimension (:), intent ( out ) :: C Character ( Len =* ), intent ( in ) :: FILE Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS Integer , Optional , intent ( in ) :: Quite ! Integer :: i Type ( CArray_1D ), Target :: A_t Class ( * ), Pointer :: Data_up ! Data_up => A_t If ( Present ( Quite ) ) Then Call Read_Data ( FILE , Data_up , ACCESS , Quite = Quite ) Else Call Read_Data ( FILE , Data_up , ACCESS ) End If ! Select Type ( Data_up ) Type is ( CArray_1D ) print * , 'Read_Write_TRNINPUT: A_t%upper   = ' , A_t % upper ( 1 ), '    ---    SHOULD BE 3 but is not' do i = 1 , A_t % upper ( 1 ) print * , 'Read_Write_TRNINPUT: A_t%Data(i) = ' , i , trim ( A_t % Data ( i )), '    ---    SEGFAULT' end do u = A_t % upper ( 1 ) Allocate ( C ( 1 : u ) ) C = A_t % Data End Select Nullify ( Data_up ) ! print * , 'Read_Write_TRNINPUT: u    = ' , u do i = 1 , u print * , 'Read_Write_TRNINPUT: C(i) = ' , i , trim ( C ( i )) end do ! End Subroutine Read_TRNINPUT ! End Module Read_Write_TRNINPUT_Mod","tags":"","loc":"sourcefile/read_write_trninput_mod.f90.html","title":"Read_Write_TRNINPUT_Mod.f90 – quarantine"},{"text":"This file depends on sourcefile~~read_write_target_material_mod.f90~~EfferentGraph sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 var pansourcefileread_write_target_material_modf90EfferentGraph = svgPanZoom('#sourcefileread_write_target_material_modf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~read_write_target_material_mod.f90~~AfferentGraph sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Read_Write_Target_Material_Mod Source Code Read_Write_Target_Material_Mod.f90 Source Code Module Read_Write_Target_Material_Mod ! Use Parameters_Mod ! Implicit None ! Private ! Public :: Read_TM ! Contains ! Subroutine Read_TM ( Num_Mats , Mat_Name , TM_Mat , ACCESS ) ! Use Read_Write_Basic_Mod , only : Read_Data Use Type_Target_Material_Mod , only : Target_Material , Target_Material_Pointer ! Implicit None ! Integer , intent ( in ) :: Num_Mats Character ( LEN =* ), Dimension ( * ), intent ( in ) :: Mat_Name Type ( Target_Material ), Allocatable , Dimension (:), intent ( out ) :: TM_Mat Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS ! Type ( Target_Material_Pointer ), Pointer , Dimension (:) :: TM_Mat_p ! Integer :: i , j , k Character ( LEN = 1000 ) :: FILE Type ( Target_Material_Pointer ), Target :: D_t Class ( * ), Pointer :: Data_up => null () ! Allocate ( TM_Mat_p ( 1 : Num_Mats ) ) Do i = 1 , Num_Mats FILE = trim ( Mat_Name ( i )) // '.mat' Data_up => D_t Call Read_Data ( FILE , Data_up , ACCESS ) Select Type ( Data_up ) Type is ( Target_Material_Pointer ) TM_mat_p ( i )% Name = Data_up % Name TM_mat_p ( i )% Num_Isotopes = Data_up % Num_Isotopes TM_mat_p ( i )% Density = Data_up % Density TM_mat_p ( i )% A_Target_Material_p => Data_up % A_target_Material_p TM_mat_p ( i )% Z_Target_Material_p => Data_up % Z_target_Material_p TM_mat_p ( i )% D_Target_Material_p => Data_up % D_target_Material_p End Select Nullify ( Data_up ) End Do ! Allocate ( TM_Mat ( 1 : Num_Mats ) ) Do i = 1 , Num_Mats TM_Mat ( i )% Name = TM_Mat_p ( i )% Name TM_Mat ( i )% Num_Isotopes = TM_Mat_p ( i )% Num_Isotopes TM_Mat ( i )% Density = TM_Mat_p ( i )% Density Allocate ( TM_Mat ( i )% A_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) Allocate ( TM_Mat ( i )% Z_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) Allocate ( TM_Mat ( i )% D_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) TM_Mat ( i )% A_Target_Material = TM_Mat_p ( i )% A_Target_Material_p TM_Mat ( i )% Z_Target_Material = TM_Mat_p ( i )% Z_Target_Material_p TM_Mat ( i )% D_Target_Material = TM_Mat_p ( i )% D_Target_Material_p End Do ! !print *, 'TM_Mat in Read_TM' !do i=1,Num_Mats !associate ( S => TM_Mat(i) ) !print *, 'Name NIso Dens: ', i, '-', trim(S%Name), '-', S%Num_Isotopes, S%Density !print *, 'a_target_material allocated? ', allocated(S%a_target_material) !print *, 'z_target_material allocated? ', allocated(S%z_target_material) !print *, 'd_target_material allocated? ', allocated(S%d_target_material) !do j=1,S%num_isotopes !print *, '     A,Z,D: ', j, S%a_target_material(j), S%z_target_material(j), S%d_target_material(j) !enddo !end associate !enddo ! End Subroutine Read_TM ! End Module Read_Write_Target_Material_Mod","tags":"","loc":"sourcefile/read_write_target_material_mod.f90.html","title":"Read_Write_Target_Material_Mod.f90 – quarantine"},{"text":"This file depends on sourcefile~~type_target_material_mod.f90~~EfferentGraph sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~type_target_material_mod.f90~~AfferentGraph sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~type_target_material_mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 var pansourcefiletype_target_material_modf90AfferentGraph = svgPanZoom('#sourcefiletype_target_material_modf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Type_Target_Material_Mod Source Code Type_Target_Material_Mod.f90 Source Code Module Type_Target_Material_Mod ! Use Parameters_Mod ! Implicit None ! Private Public :: Read_Target_Material , Write_Target_Material Public :: Target_Material , Target_Material_Pointer ! Type Target_Material_Pointer Character ( LEN = CLEN_SIZE ) :: Name Integer :: Num_Isotopes Real :: Density Real , Pointer , Dimension (:) :: A_Target_Material_p => null (), Z_Target_Material_p => null (), D_Target_Material_p => null () End Type Target_Material_Pointer ! Type Target_Material Character ( LEN = CLEN_SIZE ) :: Name Integer :: Num_Isotopes Real :: Density Real , Allocatable , Dimension (:) :: A_Target_Material , Z_Target_Material , D_Target_Material End Type Target_Material ! Contains ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 ! Subroutine Read_Target_Material ( LU , Binary , D ) ! !********************************************************************************************************************************** ! This subroutine is for the Target_Material derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type Target_Material !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( Target_Material_Pointer ), intent ( out ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Make sure the A_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc1 : If ( Associated ( D % A_Target_Material_p ) ) Then Write ( * , '(a)' ) 'A_Target_Material_p already Associated - nullify' Nullify ( D % A_Target_Material_p ) End If DMAlc1 ! !********************************************************************************************************************************** ! Make sure the Z_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc2 : If ( Associated ( D % Z_Target_Material_p ) ) Then Write ( * , '(a)' ) 'Z_Target_Material_p already Associated - nullify' Nullify ( D % Z_Target_Material_p ) End If DMAlc2 ! !********************************************************************************************************************************** ! Make sure the D_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc3 : If ( Associated ( D % D_Target_Material_p ) ) Then Write ( * , '(a)' ) 'D_Target_Material_p already Associated - nullify' Nullify ( D % D_Target_Material_p ) End If DMAlc3 ! !********************************************************************************************************************************** ! Read the file to get the Name, Num_Isotopes, and Density !********************************************************************************************************************************** ! bin1 : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density End If bin1 R1err : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Constant Line Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Target_Material' End If R1err ! !********************************************************************************************************************************** ! Allocate Arrays !********************************************************************************************************************************** ! Allocate ( D % A_Target_Material_p ( 1 : D % Num_Isotopes ), D % Z_Target_Material_p ( 1 : D % Num_Isotopes ), D % D_Target_Material_p ( 1 : D % Num_Isotopes ) ) ! !********************************************************************************************************************************** ! Read the data !********************************************************************************************************************************** ! Do i = 1 , D % Num_Isotopes bin2 : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) End If bin2 End Do R2err : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Target Data Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Target_Material' End If R2err ! !********************************************************************************************************************************** ! Return to calling programs !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of Subroutine !********************************************************************************************************************************** ! End Subroutine Read_Target_Material ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 ! Subroutine Write_Target_Material ( LU , Binary , D ) ! !********************************************************************************************************************************** ! This subroutine is for the Target_Material derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type Target_Material !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( Target_Material_Pointer ), intent ( in ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - Do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Write the front data !********************************************************************************************************************************** ! bin1 : If ( Binary ) Then Write ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density Else Write ( unit = LU , fmt = '(a,/,i10,/,1pe14.6)' , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density End If bin1 ! !********************************************************************************************************************************** ! Write the isotope data !********************************************************************************************************************************** ! Do i = 1 , D % Num_Isotopes bin2 : If ( Binary ) Then Write ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) Else Write ( unit = LU , fmt = '(3(1x,1pe14.6))' , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) End If bin2 End Do ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End for Write_Target_Material !********************************************************************************************************************************** ! End Subroutine Write_Target_Material ! End Module Type_Target_Material_Mod","tags":"","loc":"sourcefile/type_target_material_mod.f90.html","title":"Type_Target_Material_Mod.f90 – quarantine"},{"text":"This file depends on sourcefile~~hzetrn_trn.f90~~EfferentGraph sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~type_target_material_mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 var pansourcefilehzetrn_trnf90EfferentGraph = svgPanZoom('#sourcefilehzetrn_trnf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs HZETRN_TRN Source Code hzetrn_trn.f90 Source Code Program HZETRN_TRN ! Use Parameters_Mod ! Use Type_Target_Material_Mod ! Use Read_Write_Target_Material_Mod Use Read_Write_TRNINPUT_Mod ! !================================================================================ !================================================================================ !                               Define Data !================================================================================ !================================================================================ ! !******************************************************************************** ! This program illistrates an error !******************************************************************************** ! Implicit None ! !******************************************************************************** ! Do loop indexes and local variables !******************************************************************************** ! Integer :: i , j ! !******************************************************************************** ! File I/O !******************************************************************************** ! Character ( LEN = CLEN_SIZE ) :: FILE ! !******************************************************************************** ! TRNInput !******************************************************************************** ! Integer :: Num_Mats_loc Character ( LEN = CLEN_SIZE ), Allocatable , Dimension (:) :: Mat_Name_loc ! !******************************************************************************** ! Target Material !******************************************************************************** ! Type ( Target_Material ), Allocatable , Dimension (:) :: TM_mat_loc ! !******************************************************************************** ! Read TRNINPUT !******************************************************************************** ! FILE = 'trninput.dat' Call Read_TRNINPUT ( FILE , Num_Mats_loc , Mat_Name_loc , 'ASC' ) ! print * , 'Num_Mats_loc = ' , Num_Mats_loc Do i = 1 , Num_Mats_loc print * , 'Mat_Name_loc =' , trim ( Mat_Name_loc ( i )), '-' End Do ! !******************************************************************************** ! Read TM !******************************************************************************** ! Call Read_TM ( Num_Mats_loc , Mat_Name_loc , TM_Mat_loc , 'ASC' ) ! print * , 'TM_Mat_loc allocated? : ' , Allocated ( TM_Mat_loc ) Do i = 1 , Num_Mats_loc print * , 'p_read: TM_Mat_loc Name, Number, Density: ' print * , trim ( TM_Mat_loc ( i )% Name ), TM_Mat_loc ( i )% Num_Isotopes , TM_Mat_loc ( i )% Density print * , 'TM_Mat_loc(i)%A allocated? : ' , Allocated ( TM_Mat_loc ( i )% A_Target_Material ) print * , 'TM_Mat_loc(i)%Z allocated? : ' , Allocated ( TM_Mat_loc ( i )% Z_Target_Material ) print * , 'TM_Mat_loc(i)%D allocated? : ' , Allocated ( TM_Mat_loc ( i )% D_Target_Material ) Do j = 1 , TM_Mat_loc ( i )% Num_Isotopes print * , 'A: ' , TM_Mat_loc ( i )% A_Target_Material ( j ) print * , 'Z: ' , TM_Mat_loc ( i )% Z_Target_Material ( j ) print * , 'D: ' , TM_Mat_loc ( i )% D_Target_Material ( j ) End Do End Do ! !******************************************************************************** ! End of Program !******************************************************************************** ! End Program HZETRN_TRN","tags":"","loc":"sourcefile/hzetrn_trn.f90.html","title":"hzetrn_trn.f90 – quarantine"},{"text":"This file depends on sourcefile~~type_carray_1d_mod.f90~~EfferentGraph sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~type_carray_1d_mod.f90~~AfferentGraph sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 var pansourcefiletype_carray_1d_modf90AfferentGraph = svgPanZoom('#sourcefiletype_carray_1d_modf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Type_CArray_1D_Mod Source Code Type_CArray_1D_Mod.f90 Source Code Module Type_CArray_1D_Mod ! Use Parameters_Mod ! Implicit None ! Private Public :: Read_CArray_1D Public :: CArray_1D ! Type :: CArray_1D Integer :: Dimen = 1 Integer , Allocatable , Dimension (:) :: lower , upper Character ( LEN = CLEN_SIZE ), Allocatable , Dimension (:) :: Data End Type CArray_1D ! Contains ! Subroutine Read_CArray_1D ( LU , Binary , D ) ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 ! !********************************************************************************************************************************** ! This subroutine is for the CArray_1D derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type CArray_1D !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( CArray_1D ), intent ( out ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Make sure the lower pointer is not allocated !********************************************************************************************************************************** ! DMAlcl : If ( Allocated ( D % lower ) ) Then Write ( * , '(a)' ) 'Lower already Allocated - Deallocate' Deallocate ( D % lower ) End If DMAlcl ! !********************************************************************************************************************************** ! Make sure the upper pointer is not allocated !********************************************************************************************************************************** ! DMAlcu : If ( Allocated ( D % upper ) ) Then Write ( * , '(a)' ) 'Upper already Allocated - Deallocate' Deallocate ( D % upper ) End If DMAlcu ! !********************************************************************************************************************************** ! Make sure the data pointer is not allocated !********************************************************************************************************************************** ! DAlc : If ( Allocated ( D % Data ) ) Then Write ( * , '(a)' ) 'Data already Allocated - Deallocate' Deallocate ( D % Data ) End If DAlc ! !********************************************************************************************************************************** ! Allocate the lower and upper array boundaries !********************************************************************************************************************************** ! Allocate ( D % lower ( d % Dimen ), D % upper ( d % Dimen ), stat = IOSTAT , errmsg = IOMSG ) DMerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Dimension Allocation Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If DMerr ! !********************************************************************************************************************************** ! Read the lower and upper array boundaries from the data file: Binary or ASCII !********************************************************************************************************************************** ! DRDif : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) ( D % lower ( i ), D % upper ( i ), i = 1 , D % Dimen ) Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) ( D % lower ( i ), D % upper ( i ), i = 1 , D % Dimen ) End If DRDif RDMerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Dimension Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If RDMerr ! !********************************************************************************************************************************** ! Allocate the data array !********************************************************************************************************************************** ! Allocate ( D % Data ( D % lower ( D % Dimen ): D % upper ( D % Dimen )), stat = IOSTAT , errmsg = IOMSG ) Derr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Data Allocation Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If Derr ! !********************************************************************************************************************************** ! Read the data array: Binary or ASCII !********************************************************************************************************************************** ! RDif : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Data Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % Data End If RDif RDerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Data Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If RDerr print * , 'Type_CArray_1D_Mod: D%upper(1) = ' , D % upper ( 1 ) do i = 1 , D % upper ( 1 ) print * , 'Type_CArray_1D_Mod: D%Data(i)  = ' , i , trim ( D % Data ( i )) enddo ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End for read CArray_1D !********************************************************************************************************************************** ! End Subroutine Read_CArray_1D ! End Module Type_CArray_1D_Mod","tags":"","loc":"sourcefile/type_carray_1d_mod.f90.html","title":"Type_CArray_1D_Mod.f90 – quarantine"},{"text":"Files dependent on this one sourcefile~~parameters_mod.f90~~AfferentGraph sourcefile~parameters_mod.f90 Parameters_Mod.f90 sourcefile~hzetrn_trn.f90 hzetrn_trn.f90 sourcefile~hzetrn_trn.f90->sourcefile~parameters_mod.f90 sourcefile~type_target_material_mod.f90 Type_Target_Material_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_target_material_mod.f90 Read_Write_Target_Material_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_target_material_mod.f90 sourcefile~read_write_trninput_mod.f90 Read_Write_TRNINPUT_Mod.f90 sourcefile~hzetrn_trn.f90->sourcefile~read_write_trninput_mod.f90 sourcefile~type_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_basic_mod.f90 Read_Write_Basic_Mod.f90 sourcefile~read_write_target_material_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~parameters_mod.f90 sourcefile~type_carray_1d_mod.f90 Type_CArray_1D_Mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~type_carray_1d_mod.f90 sourcefile~read_write_trninput_mod.f90->sourcefile~read_write_basic_mod.f90 sourcefile~type_carray_1d_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~parameters_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_target_material_mod.f90 sourcefile~read_write_basic_mod.f90->sourcefile~type_carray_1d_mod.f90 var pansourcefileparameters_modf90AfferentGraph = svgPanZoom('#sourcefileparameters_modf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Parameters_Mod Source Code Parameters_Mod.f90 Source Code Module Parameters_Mod ! Implicit None ! !********************************************************************************************************************************** ! Characters: Define the output format of all ASCII data written to a file. ! Integers: Defines the data used to calulate sizes of read/write file !********************************************************************************************************************************** !                                                         12345678901234567 Character ( Len = 17 ), Parameter :: DATA_FORMAT_SIZE = '(:,5(1x,1pe14.7))' Integer , Parameter :: ASCII_DATA_SIZE = 1 + 14 !                                                         123456789012 Character ( Len = 12 ), Parameter :: CDATA_FORMAT_SIZE = '(:,(1x,a))' !                                                         123456789012345 Character ( Len = 15 ), Parameter :: BOUND_FORMAT_SIZE = '(:,10(1x,i5.5))' Integer , Parameter :: ASCII_BOUND_SIZE = 1 + 5 ! !********************************************************************************************************************************** ! Define the length of all string sizes !********************************************************************************************************************************** ! Integer , Parameter :: CLEN_SIZE = 1024 Integer , Parameter :: IOMSG_SIZE = 120 ! !********************************************************************************************************************************** ! Data for default file format !       For Binary file formats: G_BINARY = .true. !       For ASCII file formats:  G_BINARY = .false. !********************************************************************************************************************************** ! Logical , Parameter :: G_BINARY = . false . ! Default value is ASCII input/output - change to .true. to be Binary input/output ! End Module Parameters_Mod","tags":"","loc":"sourcefile/parameters_mod.f90.html","title":"Parameters_Mod.f90 – quarantine"},{"text":"type, public :: Target_Material Contents Variables A_Target_Material D_Target_Material Density Name Num_Isotopes Z_Target_Material Source Code Target_Material Components Type Visibility Attributes Name Initial real, public, Allocatable, Dimension(:) :: A_Target_Material real, public, Allocatable, Dimension(:) :: D_Target_Material real, public :: Density character(len=CLEN_SIZE), public :: Name integer, public :: Num_Isotopes real, public, Allocatable, Dimension(:) :: Z_Target_Material Source Code Type Target_Material Character ( LEN = CLEN_SIZE ) :: Name Integer :: Num_Isotopes Real :: Density Real , Allocatable , Dimension (:) :: A_Target_Material , Z_Target_Material , D_Target_Material End Type Target_Material","tags":"","loc":"type/target_material.html","title":"Target_Material – quarantine "},{"text":"type, public :: Target_Material_Pointer Contents Variables A_Target_Material_p D_Target_Material_p Density Name Num_Isotopes Z_Target_Material_p Source Code Target_Material_Pointer Components Type Visibility Attributes Name Initial real, public, Pointer, Dimension(:) :: A_Target_Material_p => null() real, public, Pointer, Dimension(:) :: D_Target_Material_p => null() real, public :: Density character(len=CLEN_SIZE), public :: Name integer, public :: Num_Isotopes real, public, Pointer, Dimension(:) :: Z_Target_Material_p => null() Source Code Type Target_Material_Pointer Character ( LEN = CLEN_SIZE ) :: Name Integer :: Num_Isotopes Real :: Density Real , Pointer , Dimension (:) :: A_Target_Material_p => null (), Z_Target_Material_p => null (), D_Target_Material_p => null () End Type Target_Material_Pointer","tags":"","loc":"type/target_material_pointer.html","title":"Target_Material_Pointer – quarantine "},{"text":"type, public :: CArray_1D Contents Variables Data Dimen lower upper Source Code CArray_1D Components Type Visibility Attributes Name Initial character(len=CLEN_SIZE), public, Allocatable, Dimension(:) :: Data integer, public :: Dimen = 1 integer, public, Allocatable, Dimension(:) :: lower integer, public, Allocatable, Dimension(:) :: upper Source Code Type :: CArray_1D Integer :: Dimen = 1 Integer , Allocatable , Dimension (:) :: lower , upper Character ( LEN = CLEN_SIZE ), Allocatable , Dimension (:) :: Data End Type CArray_1D","tags":"","loc":"type/carray_1d.html","title":"CArray_1D – quarantine "},{"text":"private function Output_Bytes(Read_Flag, FILE, Binary, Dimen, lower, upper) result(OBytes) No implicit typing FILE - The file name just read/written\n Read_Flag - .true. if reading; .false. if writting\n Binary - .true if binary and .false. if ASCII\n Dimen - The dimension of the array being read/written\n lower - The lower bounds of the array indicies\n upper - The upper bounds of the array indicies\n OBytes - The number of BYTES read/written to/from a file (needs to be I*8) Determine the size in Bytes of an ASCII data file End of IF block on data size determination Set the function result to an integer of size - use default fortran 2003 conversion\n   This is in BYTES Find the 1024 byte scale that brings the size between >=1 and <1024 then set unit to the two letter code for the scale factor Tell the user - whether a read or write Return to calling program End of function Output_Bytes Arguments Type Intent Optional Attributes Name logical, intent(in) :: Read_Flag character(len=*), intent(in) :: FILE logical, intent(in) :: Binary integer, intent(in) :: Dimen integer, intent(in) :: lower (1:Dimen) integer, intent(in) :: upper (1:Dimen) Return Value integer Local Varaibles\n   Data_size - The size in B/kB/MB/GB/TB of the data\n   unit - The unit used in the write statement\n   punit - The possible sizes allowed\n   i - Do loop index Called by proc~~output_bytes~~CalledByGraph proc~output_bytes Output_Bytes proc~read_data Read_Data proc~read_data->proc~output_bytes proc~read_tm Read_TM proc~read_tm->proc~read_data proc~read_trninput Read_TRNINPUT proc~read_trninput->proc~read_data program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_tm program~hzetrn_trn->proc~read_trninput Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Output_Bytes Source Code Function Output_Bytes ( Read_flag , FILE , Binary , Dimen , lower , upper ) Result ( OBytes ) ! !********************************************************************************************************************************** ! No implicit typing !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! FILE - The file name just read/written ! Read_Flag - .true. if reading; .false. if writting ! Binary - .true if binary and .false. if ASCII ! Dimen - The dimension of the array being read/written ! lower - The lower bounds of the array indicies ! upper - The upper bounds of the array indicies ! OBytes - The number of BYTES read/written to/from a file (needs to be I*8) !********************************************************************************************************************************** ! Character ( Len =* ), intent ( in ) :: FILE Logical , intent ( in ) :: Read_Flag , Binary Integer , intent ( in ) :: Dimen , lower ( 1 : Dimen ), upper ( 1 : Dimen ) Integer :: OBytes ! !********************************************************************************************************************************** ! Local Varaibles !   Data_size - The size in B/kB/MB/GB/TB of the data !   unit - The unit used in the write statement !   punit - The possible sizes allowed !   i - Do loop index !********************************************************************************************************************************** ! Real :: Data_size Character ( Len = 2 ) :: unit , punit ( 5 ) = [ 'B ' , 'kB' , 'MB' , 'GB' , 'TB' ] Integer :: i ! !********************************************************************************************************************************** ! Determine the size in Bytes of a binary data file !********************************************************************************************************************************** ! IFBin : If ( Binary ) Then Data_size = 1.0d0 DoBsize : Do i = 1 , Dimen Data_size = Data_size * ( upper ( i ) - lower ( i ) + 1 ) End Do DoBSize Data_size = Data_size * kind ( Data_size ) Data_size = Data_size + ( 2 * Dimen * kind ( upper ( 1 )) ) ! !********************************************************************************************************************************** ! Determine the size in Bytes of an ASCII data file !********************************************************************************************************************************** ! Else Data_size = 1.0d0 DoAsize : Do i = 1 , Dimen Data_size = Data_size * ( upper ( i ) - lower ( i ) + 1 ) End Do DoASize Data_size = Data_size * ASCII_DATA_SIZE Data_size = Data_size + ( 2 * Dimen * ASCII_BOUND_SIZE ) ! !********************************************************************************************************************************** ! End of IF block on data size determination !********************************************************************************************************************************** ! End If IFBin ! !********************************************************************************************************************************** ! Set the function result to an integer of size - use default fortran 2003 conversion !   This is in BYTES !********************************************************************************************************************************** ! OBytes = Int ( Data_size ) ! !********************************************************************************************************************************** ! Find the 1024 byte scale that brings the size between >=1 and <1024 then set unit to the two letter code for the scale factor !********************************************************************************************************************************** ! unit = 'ER' Dounit : Do i = 1 , 5 If ( Data_size . ge . 1.0d0 . and . Data_size . lt . 102 4.0d0 ) Then unit = punit ( i ) exit End If Data_size = Data_size / 102 4.0d0 End Do Dounit ! !********************************************************************************************************************************** ! Tell the user - whether a read or write !********************************************************************************************************************************** ! IfRDF : If ( Read_flag ) Then Write ( * , '(1x,f14.7,1x,a2,a,a)' ) Data_size , unit , ' read from ' , trim ( FILE ) Else Write ( * , '(1x,f14.7,1x,a2,a,a)' ) Data_size , unit , ' written to ' , trim ( FILE ) End If IfRDF ! !********************************************************************************************************************************** ! Return to calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of function Output_Bytes !********************************************************************************************************************************** ! End Function Output_Bytes","tags":"","loc":"proc/output_bytes.html","title":"Output_Bytes – quarantine"},{"text":"public subroutine Read_Data(FILE, Data_up, ACCESS, OBytes, Opt_Int, Quite) Uses Type_CArray_1D_Mod Type_Target_Material_Mod proc~~read_data~~UsesGraph proc~read_data Read_Data module~type_target_material_mod Type_Target_Material_Mod proc~read_data->module~type_target_material_mod module~type_carray_1d_mod Type_CArray_1D_Mod proc~read_data->module~type_carray_1d_mod module~parameters_mod Parameters_Mod module~type_target_material_mod->module~parameters_mod module~type_carray_1d_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This routine reads data into the data type passed by Data_up and passes it back to the calling routine.\n       The data type is queried below and the proper set of reads are used.\n       Any data type can be read with this routine. Use needed modules for data definitions No implicit data typing Data_up - An unlimited polymorphic Pointer that points to the data straucture to be read\n FILE - The file name to open and connect to the LU\n ACCESS - Optional value of BIN or ASC to open the file formatted ro unformatted manually.\n               The default is in the global variable G_Binary\n OBytes - Optional output for the output number of bytes read\n Opt_Int - Optional Integer to pass to type routine\n Quite - Optional Integer argument to not have data read output if defined, value unimportant Determine access for file open (formatted or unformatted) Open the data file for read Select code execution on the data type being read Type: CArray_1D - read data and tell user how many bytes read Type Target_Material - read data Class Default - Error out End Select Type on Data_up Close the Data File Return to the calling program End of Subroutine Read_Data Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FILE class(*), intent(in), Pointer :: Data_up character(len=3), intent(in), optional :: ACCESS integer, intent(out), optional :: OBytes integer, intent(inout), optional :: Opt_Int integer, intent(in), optional :: Quite Local variables\n   i - do loop index\n   LU - The Logical Unit number to read\n   IOSTAT - Message buffer from IO errors\n   NOBytes - The function to determine BYTES read\n   IOMSG - Message buffer from memory managment errors\n   NAM - Return from Inquire Function that contains the name of the opened data file\n   FORM - The string used to open the file formatted or unformatted\n   Binary - Flag for Binary (unformatted - true) or ASCII (formatted - false) data access\n   OPENED - Flag for opened data file or not from the Inquire function\n   RW - Flag to determine if reading or writting to Output_Bytes Calls proc~~read_data~~CallsGraph proc~read_data Read_Data proc~read_target_material Read_Target_Material proc~read_data->proc~read_target_material proc~output_bytes Output_Bytes proc~read_data->proc~output_bytes proc~read_carray_1d Read_CArray_1D proc~read_data->proc~read_carray_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_data~~CalledByGraph proc~read_data Read_Data proc~read_tm Read_TM proc~read_tm->proc~read_data proc~read_trninput Read_TRNINPUT proc~read_trninput->proc~read_data program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_tm program~hzetrn_trn->proc~read_trninput Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Read_Data Source Code Subroutine Read_Data ( FILE , Data_up , ACCESS , OBytes , Opt_Int , Quite ) ! !********************************************************************************************************************************** ! This routine reads data into the data type passed by Data_up and passes it back to the calling routine. !       The data type is queried below and the proper set of reads are used. !       Any data type can be read with this routine. !********************************************************************************************************************************** ! Use needed modules for data definitions !********************************************************************************************************************************** ! Use Type_CArray_1D_Mod Use Type_Target_Material_Mod ! !********************************************************************************************************************************** ! No implicit data typing !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! Data_up - An unlimited polymorphic Pointer that points to the data straucture to be read ! FILE - The file name to open and connect to the LU ! ACCESS - Optional value of BIN or ASC to open the file formatted ro unformatted manually. !               The default is in the global variable G_Binary ! OBytes - Optional output for the output number of bytes read ! Opt_Int - Optional Integer to pass to type routine ! Quite - Optional Integer argument to not have data read output if defined, value unimportant !********************************************************************************************************************************** ! Class ( * ), Pointer , intent ( in ) :: Data_up Character ( Len =* ), intent ( in ) :: FILE Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS Integer , Optional , intent ( out ) :: OBytes Integer , Optional , intent ( inout ) :: Opt_Int Integer , Optional , intent ( in ) :: Quite ! !********************************************************************************************************************************** ! Local variables !   i - do loop index !   LU - The Logical Unit number to read !   IOSTAT - Message buffer from IO errors !   NOBytes - The function to determine BYTES read !   IOMSG - Message buffer from memory managment errors !   NAM - Return from Inquire Function that contains the name of the opened data file !   FORM - The string used to open the file formatted or unformatted !   Binary - Flag for Binary (unformatted - true) or ASCII (formatted - false) data access !   OPENED - Flag for opened data file or not from the Inquire function !   RW - Flag to determine if reading or writting to Output_Bytes !********************************************************************************************************************************** ! Integer :: i , LU , IOSTAT Integer :: NOBytes Character ( LEN = IOMSG_SIZE ) :: IOMSG Character ( LEN = CLEN_SIZE ) :: NAM Character ( LEN = 11 ) :: FORM Logical :: Speak , Binary , OPENED , RW = . true . ! !********************************************************************************************************************************** ! Determine if Quite is defined !********************************************************************************************************************************** ! Speak = . true . Q : If ( Present ( Quite ) ) Then Speak = . false . End If Q ! !********************************************************************************************************************************** ! Determine access for file open (formatted or unformatted) !********************************************************************************************************************************** ! DACif : If ( . not . Present ( ACCESS ) ) Then Binary = G_BINARY BINIf : If ( Binary ) Then FORM = 'unformatted' Else FORM = 'formatted' End If BINIf Else ACif : If ( ACCESS ( 1 : 3 ) . eq . 'BIN' ) Then FORM = 'unformatted' ; Binary = . true . Else If ( ACCESS ( 1 : 3 ) . eq . 'ASC' ) Then FORM = 'formatted' ; Binary = . false . Else Write ( * , * ) 'Optional ACCESS present does not equal \"BIN\" or \"ASC\"' Write ( * , * ) 'ACCESS = ' , ACCESS ( 1 : 3 ) Stop 'Abort Read_Data' End If ACif End If DACif ! !********************************************************************************************************************************** ! Open the data file for read !********************************************************************************************************************************** ! Open ( newunit = LU , file = trim ( FILE ), status = 'old' , form = trim ( FORM ), action = 'read' , iostat = IOSTAT , iomsg = IOMSG ) OPerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'File Open Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Data' End If OPerr ! !********************************************************************************************************************************** ! Select code execution on the data type being read !********************************************************************************************************************************** ! DUPtyp : Select Type ( Data_up ) ! !********************************************************************************************************************************** ! Type: CArray_1D - read data and tell user how many bytes read !********************************************************************************************************************************** ! Type is ( CArray_1D ) ! Call Read_CArray_1D ( LU , Binary , Data_up ) Q_C1D : If ( Speak ) Then WObytes_C1D : If ( present ( OBytes ) ) Then !                        OBytes = Output_Bytes ( RW, FILE, Binary, Data_up%Dimen, Data_up%lower_p, Data_up%upper_p ) OBytes = Output_Bytes ( RW , FILE , Binary , Data_up % Dimen , Data_up % lower , Data_up % upper ) Else !                        NObytes = Output_Bytes ( RW, FILE, Binary, Data_up%Dimen, Data_up%lower_p, Data_up%upper_p ) NObytes = Output_Bytes ( RW , FILE , Binary , Data_up % Dimen , Data_up % lower , Data_up % upper ) End If WOBytes_C1D End If Q_C1D print * , 'Read_Write_Basic_Mod: Data_up%upper(1) = ' , Data_up % upper ( 1 ) do i = 1 , Data_up % upper ( 1 ) print * , '                      Data_up%Data(i)  = ' , i , trim ( Data_up % Data ( i )) enddo ! !********************************************************************************************************************************** ! Type Target_Material - read data !********************************************************************************************************************************** ! Type is ( Target_Material_Pointer ) ! Call Read_Target_Material ( LU , Binary , Data_up ) Q_Targ : If ( Speak ) Then Write ( * , * ) 'Read ' , trim ( FILE ), ' - no size data available' End If Q_Targ ! ! !********************************************************************************************************************************** ! Class Default - Error out !********************************************************************************************************************************** ! Class Default ! Write ( * , '(a,i0,1x,a)' ) 'The class of the data passed to Read_Data was not recognized' Stop 'Abort Read_Data' ! !********************************************************************************************************************************** ! End Select Type on Data_up !********************************************************************************************************************************** ! End Select DUPTyp ! !********************************************************************************************************************************** ! Close the Data File !********************************************************************************************************************************** ! Close ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) CLerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'File Close Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Data' End If CLerr ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of Subroutine Read_Data !********************************************************************************************************************************** ! End Subroutine Read_Data","tags":"","loc":"proc/read_data.html","title":"Read_Data – quarantine"},{"text":"public subroutine Read_TRNINPUT(FILE, u, C, ACCESS, Quite) Uses Read_Write_Basic_Mod Type_CArray_1D_Mod proc~~read_trninput~~UsesGraph proc~read_trninput Read_TRNINPUT module~type_carray_1d_mod Type_CArray_1D_Mod proc~read_trninput->module~type_carray_1d_mod module~read_write_basic_mod Read_Write_Basic_Mod proc~read_trninput->module~read_write_basic_mod module~parameters_mod Parameters_Mod module~type_carray_1d_mod->module~parameters_mod module~read_write_basic_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FILE integer, intent(out), Target :: u character(len=CLEN_SIZE), intent(out), Target, Allocatable, Dimension(:) :: C character(len=3), intent(in), optional :: ACCESS integer, intent(in), optional :: Quite Calls proc~~read_trninput~~CallsGraph proc~read_trninput Read_TRNINPUT proc~read_data Read_Data proc~read_trninput->proc~read_data proc~read_target_material Read_Target_Material proc~read_data->proc~read_target_material proc~output_bytes Output_Bytes proc~read_data->proc~output_bytes proc~read_carray_1d Read_CArray_1D proc~read_data->proc~read_carray_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_trninput~~CalledByGraph proc~read_trninput Read_TRNINPUT program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_trninput Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Read_TRNINPUT Source Code Subroutine Read_TRNINPUT ( FILE , u , C , ACCESS , Quite ) ! Use Read_Write_Basic_Mod , only : Read_Data Use Type_CArray_1D_Mod , only : CArray_1D ! Implicit None ! Integer , Target , intent ( out ) :: u Character ( LEN = CLEN_SIZE ), Target , Allocatable , Dimension (:), intent ( out ) :: C Character ( Len =* ), intent ( in ) :: FILE Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS Integer , Optional , intent ( in ) :: Quite ! Integer :: i Type ( CArray_1D ), Target :: A_t Class ( * ), Pointer :: Data_up ! Data_up => A_t If ( Present ( Quite ) ) Then Call Read_Data ( FILE , Data_up , ACCESS , Quite = Quite ) Else Call Read_Data ( FILE , Data_up , ACCESS ) End If ! Select Type ( Data_up ) Type is ( CArray_1D ) print * , 'Read_Write_TRNINPUT: A_t%upper   = ' , A_t % upper ( 1 ), '    ---    SHOULD BE 3 but is not' do i = 1 , A_t % upper ( 1 ) print * , 'Read_Write_TRNINPUT: A_t%Data(i) = ' , i , trim ( A_t % Data ( i )), '    ---    SEGFAULT' end do u = A_t % upper ( 1 ) Allocate ( C ( 1 : u ) ) C = A_t % Data End Select Nullify ( Data_up ) ! print * , 'Read_Write_TRNINPUT: u    = ' , u do i = 1 , u print * , 'Read_Write_TRNINPUT: C(i) = ' , i , trim ( C ( i )) end do ! End Subroutine Read_TRNINPUT","tags":"","loc":"proc/read_trninput.html","title":"Read_TRNINPUT – quarantine"},{"text":"public subroutine Read_TM(Num_Mats, Mat_Name, TM_Mat, ACCESS) Uses Read_Write_Basic_Mod Type_Target_Material_Mod proc~~read_tm~~UsesGraph proc~read_tm Read_TM module~type_target_material_mod Type_Target_Material_Mod proc~read_tm->module~type_target_material_mod module~read_write_basic_mod Read_Write_Basic_Mod proc~read_tm->module~read_write_basic_mod module~parameters_mod Parameters_Mod module~type_target_material_mod->module~parameters_mod module~read_write_basic_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: Num_Mats character(len=*), intent(in), Dimension(*) :: Mat_Name type( Target_Material ), intent(out), Allocatable, Dimension(:) :: TM_Mat character(len=3), intent(in), optional :: ACCESS Calls proc~~read_tm~~CallsGraph proc~read_tm Read_TM proc~read_data Read_Data proc~read_tm->proc~read_data proc~read_target_material Read_Target_Material proc~read_data->proc~read_target_material proc~output_bytes Output_Bytes proc~read_data->proc~output_bytes proc~read_carray_1d Read_CArray_1D proc~read_data->proc~read_carray_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_tm~~CalledByGraph proc~read_tm Read_TM program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_tm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Read_TM Source Code Subroutine Read_TM ( Num_Mats , Mat_Name , TM_Mat , ACCESS ) ! Use Read_Write_Basic_Mod , only : Read_Data Use Type_Target_Material_Mod , only : Target_Material , Target_Material_Pointer ! Implicit None ! Integer , intent ( in ) :: Num_Mats Character ( LEN =* ), Dimension ( * ), intent ( in ) :: Mat_Name Type ( Target_Material ), Allocatable , Dimension (:), intent ( out ) :: TM_Mat Character ( Len = 3 ), Optional , intent ( in ) :: ACCESS ! Type ( Target_Material_Pointer ), Pointer , Dimension (:) :: TM_Mat_p ! Integer :: i , j , k Character ( LEN = 1000 ) :: FILE Type ( Target_Material_Pointer ), Target :: D_t Class ( * ), Pointer :: Data_up => null () ! Allocate ( TM_Mat_p ( 1 : Num_Mats ) ) Do i = 1 , Num_Mats FILE = trim ( Mat_Name ( i )) // '.mat' Data_up => D_t Call Read_Data ( FILE , Data_up , ACCESS ) Select Type ( Data_up ) Type is ( Target_Material_Pointer ) TM_mat_p ( i )% Name = Data_up % Name TM_mat_p ( i )% Num_Isotopes = Data_up % Num_Isotopes TM_mat_p ( i )% Density = Data_up % Density TM_mat_p ( i )% A_Target_Material_p => Data_up % A_target_Material_p TM_mat_p ( i )% Z_Target_Material_p => Data_up % Z_target_Material_p TM_mat_p ( i )% D_Target_Material_p => Data_up % D_target_Material_p End Select Nullify ( Data_up ) End Do ! Allocate ( TM_Mat ( 1 : Num_Mats ) ) Do i = 1 , Num_Mats TM_Mat ( i )% Name = TM_Mat_p ( i )% Name TM_Mat ( i )% Num_Isotopes = TM_Mat_p ( i )% Num_Isotopes TM_Mat ( i )% Density = TM_Mat_p ( i )% Density Allocate ( TM_Mat ( i )% A_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) Allocate ( TM_Mat ( i )% Z_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) Allocate ( TM_Mat ( i )% D_Target_Material ( TM_Mat ( i )% Num_Isotopes ) ) TM_Mat ( i )% A_Target_Material = TM_Mat_p ( i )% A_Target_Material_p TM_Mat ( i )% Z_Target_Material = TM_Mat_p ( i )% Z_Target_Material_p TM_Mat ( i )% D_Target_Material = TM_Mat_p ( i )% D_Target_Material_p End Do ! !print *, 'TM_Mat in Read_TM' !do i=1,Num_Mats !associate ( S => TM_Mat(i) ) !print *, 'Name NIso Dens: ', i, '-', trim(S%Name), '-', S%Num_Isotopes, S%Density !print *, 'a_target_material allocated? ', allocated(S%a_target_material) !print *, 'z_target_material allocated? ', allocated(S%z_target_material) !print *, 'd_target_material allocated? ', allocated(S%d_target_material) !do j=1,S%num_isotopes !print *, '     A,Z,D: ', j, S%a_target_material(j), S%z_target_material(j), S%d_target_material(j) !enddo !end associate !enddo ! End Subroutine Read_TM","tags":"","loc":"proc/read_tm.html","title":"Read_TM – quarantine"},{"text":"public subroutine Read_Target_Material(LU, Binary, D) This subroutine is for the Target_Material derived type data read LU - The logical unit for input\n Binary - Flag for binary or ASCII input\n D - The data to pass back and is of type Target_Material Make sure the Z_Target_Material_p pointer is not associated Make sure the D_Target_Material_p pointer is not associated Read the file to get the Name, Num_Isotopes, and Density Allocate Arrays Read the data Return to calling programs End of Subroutine Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( Target_Material_Pointer ), intent(out) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - do loop variable Called by proc~~read_target_material~~CalledByGraph proc~read_target_material Read_Target_Material proc~read_data Read_Data proc~read_data->proc~read_target_material proc~read_tm Read_TM proc~read_tm->proc~read_data proc~read_trninput Read_TRNINPUT proc~read_trninput->proc~read_data program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_tm program~hzetrn_trn->proc~read_trninput Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Read_Target_Material Source Code Subroutine Read_Target_Material ( LU , Binary , D ) ! !********************************************************************************************************************************** ! This subroutine is for the Target_Material derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type Target_Material !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( Target_Material_Pointer ), intent ( out ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Make sure the A_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc1 : If ( Associated ( D % A_Target_Material_p ) ) Then Write ( * , '(a)' ) 'A_Target_Material_p already Associated - nullify' Nullify ( D % A_Target_Material_p ) End If DMAlc1 ! !********************************************************************************************************************************** ! Make sure the Z_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc2 : If ( Associated ( D % Z_Target_Material_p ) ) Then Write ( * , '(a)' ) 'Z_Target_Material_p already Associated - nullify' Nullify ( D % Z_Target_Material_p ) End If DMAlc2 ! !********************************************************************************************************************************** ! Make sure the D_Target_Material_p pointer is not associated !********************************************************************************************************************************** ! DMAlc3 : If ( Associated ( D % D_Target_Material_p ) ) Then Write ( * , '(a)' ) 'D_Target_Material_p already Associated - nullify' Nullify ( D % D_Target_Material_p ) End If DMAlc3 ! !********************************************************************************************************************************** ! Read the file to get the Name, Num_Isotopes, and Density !********************************************************************************************************************************** ! bin1 : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density End If bin1 R1err : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Constant Line Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Target_Material' End If R1err ! !********************************************************************************************************************************** ! Allocate Arrays !********************************************************************************************************************************** ! Allocate ( D % A_Target_Material_p ( 1 : D % Num_Isotopes ), D % Z_Target_Material_p ( 1 : D % Num_Isotopes ), D % D_Target_Material_p ( 1 : D % Num_Isotopes ) ) ! !********************************************************************************************************************************** ! Read the data !********************************************************************************************************************************** ! Do i = 1 , D % Num_Isotopes bin2 : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) End If bin2 End Do R2err : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Target Data Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_Target_Material' End If R2err ! !********************************************************************************************************************************** ! Return to calling programs !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End of Subroutine !********************************************************************************************************************************** ! End Subroutine Read_Target_Material","tags":"","loc":"proc/read_target_material.html","title":"Read_Target_Material – quarantine"},{"text":"public subroutine Write_Target_Material(LU, Binary, D) This subroutine is for the Target_Material derived type data read LU - The logical unit for input\n Binary - Flag for binary or ASCII input\n D - The data to pass back and is of type Target_Material Write the isotope data Return to the calling program End for Write_Target_Material Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( Target_Material_Pointer ), intent(in) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - Do loop variable Contents Source Code Write_Target_Material Source Code Subroutine Write_Target_Material ( LU , Binary , D ) ! !********************************************************************************************************************************** ! This subroutine is for the Target_Material derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type Target_Material !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( Target_Material_Pointer ), intent ( in ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - Do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Write the front data !********************************************************************************************************************************** ! bin1 : If ( Binary ) Then Write ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density Else Write ( unit = LU , fmt = '(a,/,i10,/,1pe14.6)' , iostat = IOSTAT , iomsg = IOMSG ) D % Name , D % Num_Isotopes , D % Density End If bin1 ! !********************************************************************************************************************************** ! Write the isotope data !********************************************************************************************************************************** ! Do i = 1 , D % Num_Isotopes bin2 : If ( Binary ) Then Write ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) Else Write ( unit = LU , fmt = '(3(1x,1pe14.6))' , iostat = IOSTAT , iomsg = IOMSG ) D % A_Target_Material_p ( i ), D % Z_Target_Material_p ( i ), D % D_Target_Material_p ( i ) End If bin2 End Do ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End for Write_Target_Material !********************************************************************************************************************************** ! End Subroutine Write_Target_Material","tags":"","loc":"proc/write_target_material.html","title":"Write_Target_Material – quarantine"},{"text":"public subroutine Read_CArray_1D(LU, Binary, D) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 This subroutine is for the CArray_1D derived type data read LU - The logical unit for input\n Binary - Flag for binary or ASCII input\n D - The data to pass back and is of type CArray_1D Make sure the upper pointer is not allocated Make sure the data pointer is not allocated Allocate the lower and upper array boundaries Read the lower and upper array boundaries from the data file: Binary or ASCII Allocate the data array Read the data array: Binary or ASCII Return to the calling program End for read CArray_1D Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( CArray_1D ), intent(out) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - do loop variable Called by proc~~read_carray_1d~~CalledByGraph proc~read_carray_1d Read_CArray_1D proc~read_data Read_Data proc~read_data->proc~read_carray_1d proc~read_tm Read_TM proc~read_tm->proc~read_data proc~read_trninput Read_TRNINPUT proc~read_trninput->proc~read_data program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->proc~read_tm program~hzetrn_trn->proc~read_trninput Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Read_CArray_1D Source Code Subroutine Read_CArray_1D ( LU , Binary , D ) ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 ! !********************************************************************************************************************************** ! This subroutine is for the CArray_1D derived type data read !********************************************************************************************************************************** ! Implicit None ! !********************************************************************************************************************************** ! LU - The logical unit for input ! Binary - Flag for binary or ASCII input ! D - The data to pass back and is of type CArray_1D !********************************************************************************************************************************** ! Integer , intent ( in ) :: LU Logical , intent ( in ) :: Binary Type ( CArray_1D ), intent ( out ) :: D ! !********************************************************************************************************************************** ! Local Varaibles !   IOSTAT - THe status of he IO statement !   IOMSG - The associate message with an error in the IO statement !   i - do loop variable !********************************************************************************************************************************** ! Integer :: IOSTAT , i Character ( Len = IOMSG_SIZE ) :: IOMSG ! !********************************************************************************************************************************** ! Make sure the lower pointer is not allocated !********************************************************************************************************************************** ! DMAlcl : If ( Allocated ( D % lower ) ) Then Write ( * , '(a)' ) 'Lower already Allocated - Deallocate' Deallocate ( D % lower ) End If DMAlcl ! !********************************************************************************************************************************** ! Make sure the upper pointer is not allocated !********************************************************************************************************************************** ! DMAlcu : If ( Allocated ( D % upper ) ) Then Write ( * , '(a)' ) 'Upper already Allocated - Deallocate' Deallocate ( D % upper ) End If DMAlcu ! !********************************************************************************************************************************** ! Make sure the data pointer is not allocated !********************************************************************************************************************************** ! DAlc : If ( Allocated ( D % Data ) ) Then Write ( * , '(a)' ) 'Data already Allocated - Deallocate' Deallocate ( D % Data ) End If DAlc ! !********************************************************************************************************************************** ! Allocate the lower and upper array boundaries !********************************************************************************************************************************** ! Allocate ( D % lower ( d % Dimen ), D % upper ( d % Dimen ), stat = IOSTAT , errmsg = IOMSG ) DMerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Dimension Allocation Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If DMerr ! !********************************************************************************************************************************** ! Read the lower and upper array boundaries from the data file: Binary or ASCII !********************************************************************************************************************************** ! DRDif : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) ( D % lower ( i ), D % upper ( i ), i = 1 , D % Dimen ) Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) ( D % lower ( i ), D % upper ( i ), i = 1 , D % Dimen ) End If DRDif RDMerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Dimension Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If RDMerr ! !********************************************************************************************************************************** ! Allocate the data array !********************************************************************************************************************************** ! Allocate ( D % Data ( D % lower ( D % Dimen ): D % upper ( D % Dimen )), stat = IOSTAT , errmsg = IOMSG ) Derr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Data Allocation Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If Derr ! !********************************************************************************************************************************** ! Read the data array: Binary or ASCII !********************************************************************************************************************************** ! RDif : If ( Binary ) Then Read ( unit = LU , iostat = IOSTAT , iomsg = IOMSG ) D % Data Else Read ( unit = LU , fmt =* , iostat = IOSTAT , iomsg = IOMSG ) D % Data End If RDif RDerr : If ( IOSTAT . ne . 0 ) Then Write ( * , '(a,i0,1x,a)' ) 'Data Read Error, IOSTAT = ' , IOSTAT , trim ( IOMSG ) Stop 'Abort Read_CArray_1D' End If RDerr print * , 'Type_CArray_1D_Mod: D%upper(1) = ' , D % upper ( 1 ) do i = 1 , D % upper ( 1 ) print * , 'Type_CArray_1D_Mod: D%Data(i)  = ' , i , trim ( D % Data ( i )) enddo ! !********************************************************************************************************************************** ! Return to the calling program !********************************************************************************************************************************** ! Return ! !********************************************************************************************************************************** ! End for read CArray_1D !********************************************************************************************************************************** ! End Subroutine Read_CArray_1D","tags":"","loc":"proc/read_carray_1d.html","title":"Read_CArray_1D – quarantine"},{"text":"This module defines the raw reads/writes of derived data types to/from a data file.  The access can be ASCII or Binary with the default being Binary.\n     This module contains 1D through 7D routines but can define array data types to 15D, the 2008 Standard (Intel allows 31D, PGI is unknown).\n     This module can handle any derived data type to be read/written to a file.  Just add the derived data type and a corresponding Read_ and Write_ subrotuine to the module.  Make it provate and it cannot be intercepted by any other routine Use'ing this module No implicit typing All names are private except as noted below Make public only the subroutine names and the data types The subrotines are define below.  The Read_Data and Write_Data subroutines are all that are public.  All other routines are private Uses Parameters_Mod module~~read_write_basic_mod~~UsesGraph module~read_write_basic_mod Read_Write_Basic_Mod module~parameters_mod Parameters_Mod module~read_write_basic_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~read_write_basic_mod~~UsedByGraph module~read_write_basic_mod Read_Write_Basic_Mod proc~read_tm Read_TM proc~read_tm->module~read_write_basic_mod proc~read_trninput Read_TRNINPUT proc~read_trninput->module~read_write_basic_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Output_Bytes Subroutines Read_Data Functions private function Output_Bytes (Read_Flag, FILE, Binary, Dimen, lower, upper) result(OBytes) No implicit typing Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: Read_Flag character(len=*), intent(in) :: FILE logical, intent(in) :: Binary integer, intent(in) :: Dimen integer, intent(in) :: lower (1:Dimen) integer, intent(in) :: upper (1:Dimen) Return Value integer Local Varaibles\n   Data_size - The size in B/kB/MB/GB/TB of the data\n   unit - The unit used in the write statement\n   punit - The possible sizes allowed\n   i - Do loop index Read more… Subroutines public subroutine Read_Data (FILE, Data_up, ACCESS, OBytes, Opt_Int, Quite) This routine reads data into the data type passed by Data_up and passes it back to the calling routine.\n       The data type is queried below and the proper set of reads are used.\n       Any data type can be read with this routine. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FILE class(*), intent(in), Pointer :: Data_up character(len=3), intent(in), optional :: ACCESS integer, intent(out), optional :: OBytes integer, intent(inout), optional :: Opt_Int integer, intent(in), optional :: Quite Local variables\n   i - do loop index\n   LU - The Logical Unit number to read\n   IOSTAT - Message buffer from IO errors\n   NOBytes - The function to determine BYTES read\n   IOMSG - Message buffer from memory managment errors\n   NAM - Return from Inquire Function that contains the name of the opened data file\n   FORM - The string used to open the file formatted or unformatted\n   Binary - Flag for Binary (unformatted - true) or ASCII (formatted - false) data access\n   OPENED - Flag for opened data file or not from the Inquire function\n   RW - Flag to determine if reading or writting to Output_Bytes Read more…","tags":"","loc":"module/read_write_basic_mod.html","title":"Read_Write_Basic_Mod – quarantine"},{"text":"Uses Parameters_Mod module~~read_write_trninput_mod~~UsesGraph module~read_write_trninput_mod Read_Write_TRNINPUT_Mod module~parameters_mod Parameters_Mod module~read_write_trninput_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~read_write_trninput_mod~~UsedByGraph module~read_write_trninput_mod Read_Write_TRNINPUT_Mod program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->module~read_write_trninput_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Read_TRNINPUT Subroutines public subroutine Read_TRNINPUT (FILE, u, C, ACCESS, Quite) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FILE integer, intent(out), Target :: u character(len=CLEN_SIZE), intent(out), Target, Allocatable, Dimension(:) :: C character(len=3), intent(in), optional :: ACCESS integer, intent(in), optional :: Quite","tags":"","loc":"module/read_write_trninput_mod.html","title":"Read_Write_TRNINPUT_Mod – quarantine"},{"text":"Uses Parameters_Mod module~~read_write_target_material_mod~~UsesGraph module~read_write_target_material_mod Read_Write_Target_Material_Mod module~parameters_mod Parameters_Mod module~read_write_target_material_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~read_write_target_material_mod~~UsedByGraph module~read_write_target_material_mod Read_Write_Target_Material_Mod program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->module~read_write_target_material_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Read_TM Subroutines public subroutine Read_TM (Num_Mats, Mat_Name, TM_Mat, ACCESS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Num_Mats character(len=*), intent(in), Dimension(*) :: Mat_Name type( Target_Material ), intent(out), Allocatable, Dimension(:) :: TM_Mat character(len=3), intent(in), optional :: ACCESS","tags":"","loc":"module/read_write_target_material_mod.html","title":"Read_Write_Target_Material_Mod – quarantine"},{"text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 Uses Parameters_Mod module~~type_target_material_mod~~UsesGraph module~type_target_material_mod Type_Target_Material_Mod module~parameters_mod Parameters_Mod module~type_target_material_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~type_target_material_mod~~UsedByGraph module~type_target_material_mod Type_Target_Material_Mod proc~read_tm Read_TM proc~read_tm->module~type_target_material_mod program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->module~type_target_material_mod proc~read_data Read_Data proc~read_data->module~type_target_material_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types Target_Material Target_Material_Pointer Subroutines Read_Target_Material Write_Target_Material Derived Types type, public :: Target_Material Components Type Visibility Attributes Name Initial real, public, Allocatable, Dimension(:) :: A_Target_Material real, public, Allocatable, Dimension(:) :: D_Target_Material real, public :: Density character(len=CLEN_SIZE), public :: Name integer, public :: Num_Isotopes real, public, Allocatable, Dimension(:) :: Z_Target_Material type, public :: Target_Material_Pointer Components Type Visibility Attributes Name Initial real, public, Pointer, Dimension(:) :: A_Target_Material_p => null() real, public, Pointer, Dimension(:) :: D_Target_Material_p => null() real, public :: Density character(len=CLEN_SIZE), public :: Name integer, public :: Num_Isotopes real, public, Pointer, Dimension(:) :: Z_Target_Material_p => null() Subroutines public subroutine Read_Target_Material (LU, Binary, D) This subroutine is for the Target_Material derived type data read Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( Target_Material_Pointer ), intent(out) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - do loop variable Read more… public subroutine Write_Target_Material (LU, Binary, D) This subroutine is for the Target_Material derived type data read Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( Target_Material_Pointer ), intent(in) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - Do loop variable Read more…","tags":"","loc":"module/type_target_material_mod.html","title":"Type_Target_Material_Mod – quarantine"},{"text":"Uses Parameters_Mod module~~type_carray_1d_mod~~UsesGraph module~type_carray_1d_mod Type_CArray_1D_Mod module~parameters_mod Parameters_Mod module~type_carray_1d_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~type_carray_1d_mod~~UsedByGraph module~type_carray_1d_mod Type_CArray_1D_Mod proc~read_data Read_Data proc~read_data->module~type_carray_1d_mod proc~read_trninput Read_TRNINPUT proc~read_trninput->module~type_carray_1d_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types CArray_1D Subroutines Read_CArray_1D Derived Types type, public :: CArray_1D Components Type Visibility Attributes Name Initial character(len=CLEN_SIZE), public, Allocatable, Dimension(:) :: Data integer, public :: Dimen = 1 integer, public, Allocatable, Dimension(:) :: lower integer, public, Allocatable, Dimension(:) :: upper Subroutines public subroutine Read_CArray_1D (LU, Binary, D) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Called by Read_Write_Basic_Mod.f90 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: LU logical, intent(in) :: Binary type( CArray_1D ), intent(out) :: D Local Varaibles\n   IOSTAT - THe status of he IO statement\n   IOMSG - The associate message with an error in the IO statement\n   i - do loop variable Read more…","tags":"","loc":"module/type_carray_1d_mod.html","title":"Type_CArray_1D_Mod – quarantine"},{"text":"Characters: Define the output format of all ASCII data written to a file.\n Integers: Defines the data used to calulate sizes of read/write file 12345678901234567 Used by module~~parameters_mod~~UsedByGraph module~parameters_mod Parameters_Mod module~type_carray_1d_mod Type_CArray_1D_Mod module~type_carray_1d_mod->module~parameters_mod module~read_write_basic_mod Read_Write_Basic_Mod module~read_write_basic_mod->module~parameters_mod program~hzetrn_trn HZETRN_TRN program~hzetrn_trn->module~parameters_mod module~type_target_material_mod Type_Target_Material_Mod program~hzetrn_trn->module~type_target_material_mod module~read_write_trninput_mod Read_Write_TRNINPUT_Mod program~hzetrn_trn->module~read_write_trninput_mod module~read_write_target_material_mod Read_Write_Target_Material_Mod program~hzetrn_trn->module~read_write_target_material_mod module~type_target_material_mod->module~parameters_mod module~read_write_trninput_mod->module~parameters_mod module~read_write_target_material_mod->module~parameters_mod proc~read_data Read_Data proc~read_data->module~type_carray_1d_mod proc~read_data->module~type_target_material_mod proc~read_tm Read_TM proc~read_tm->module~read_write_basic_mod proc~read_tm->module~type_target_material_mod proc~read_trninput Read_TRNINPUT proc~read_trninput->module~type_carray_1d_mod proc~read_trninput->module~read_write_basic_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ASCII_BOUND_SIZE ASCII_DATA_SIZE BOUND_FORMAT_SIZE CDATA_FORMAT_SIZE CLEN_SIZE DATA_FORMAT_SIZE G_BINARY IOMSG_SIZE Variables Type Visibility Attributes Name Initial integer, public, parameter :: ASCII_BOUND_SIZE = 1+5 Define the length of all string sizes integer, public, parameter :: ASCII_DATA_SIZE = 1+14 character(len=15), public, parameter :: BOUND_FORMAT_SIZE = '(:,10(1x,i5.5))' character(len=12), public, parameter :: CDATA_FORMAT_SIZE = '(:,(1x,a))' integer, public, parameter :: CLEN_SIZE = 1024 character(len=17), public, parameter :: DATA_FORMAT_SIZE = '(:,5(1x,1pe14.7))' logical, public, parameter :: G_BINARY = .false. integer, public, parameter :: IOMSG_SIZE = 120 Data for default file format\n       For Binary file formats: G_BINARY = .true.\n       For ASCII file formats:  G_BINARY = .false.","tags":"","loc":"module/parameters_mod.html","title":"Parameters_Mod – quarantine"},{"text":"Uses Parameters_Mod Type_Target_Material_Mod Read_Write_Target_Material_Mod Read_Write_TRNINPUT_Mod program~~hzetrn_trn~~UsesGraph program~hzetrn_trn HZETRN_TRN module~parameters_mod Parameters_Mod program~hzetrn_trn->module~parameters_mod module~type_target_material_mod Type_Target_Material_Mod program~hzetrn_trn->module~type_target_material_mod module~read_write_target_material_mod Read_Write_Target_Material_Mod program~hzetrn_trn->module~read_write_target_material_mod module~read_write_trninput_mod Read_Write_TRNINPUT_Mod program~hzetrn_trn->module~read_write_trninput_mod module~type_target_material_mod->module~parameters_mod module~read_write_target_material_mod->module~parameters_mod module~read_write_trninput_mod->module~parameters_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This program illistrates an error Do loop indexes and local variables Read TM End of Program Calls program~~hzetrn_trn~~CallsGraph program~hzetrn_trn HZETRN_TRN proc~read_tm Read_TM program~hzetrn_trn->proc~read_tm proc~read_trninput Read_TRNINPUT program~hzetrn_trn->proc~read_trninput proc~read_data Read_Data proc~read_tm->proc~read_data proc~read_trninput->proc~read_data proc~read_target_material Read_Target_Material proc~read_data->proc~read_target_material proc~output_bytes Output_Bytes proc~read_data->proc~output_bytes proc~read_carray_1d Read_CArray_1D proc~read_data->proc~read_carray_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables FILE Mat_Name_loc Num_Mats_loc TM_mat_loc i j Source Code HZETRN_TRN Variables Type Attributes Name Initial character(len=CLEN_SIZE) :: FILE TRNInput character(len=CLEN_SIZE), Allocatable, Dimension(:) :: Mat_Name_loc Target Material integer :: Num_Mats_loc type(Target_Material), Allocatable, Dimension(:) :: TM_mat_loc Read TRNINPUT integer :: i File I/O integer :: j File I/O Source Code Program HZETRN_TRN ! Use Parameters_Mod ! Use Type_Target_Material_Mod ! Use Read_Write_Target_Material_Mod Use Read_Write_TRNINPUT_Mod ! !================================================================================ !================================================================================ !                               Define Data !================================================================================ !================================================================================ ! !******************************************************************************** ! This program illistrates an error !******************************************************************************** ! Implicit None ! !******************************************************************************** ! Do loop indexes and local variables !******************************************************************************** ! Integer :: i , j ! !******************************************************************************** ! File I/O !******************************************************************************** ! Character ( LEN = CLEN_SIZE ) :: FILE ! !******************************************************************************** ! TRNInput !******************************************************************************** ! Integer :: Num_Mats_loc Character ( LEN = CLEN_SIZE ), Allocatable , Dimension (:) :: Mat_Name_loc ! !******************************************************************************** ! Target Material !******************************************************************************** ! Type ( Target_Material ), Allocatable , Dimension (:) :: TM_mat_loc ! !******************************************************************************** ! Read TRNINPUT !******************************************************************************** ! FILE = 'trninput.dat' Call Read_TRNINPUT ( FILE , Num_Mats_loc , Mat_Name_loc , 'ASC' ) ! print * , 'Num_Mats_loc = ' , Num_Mats_loc Do i = 1 , Num_Mats_loc print * , 'Mat_Name_loc =' , trim ( Mat_Name_loc ( i )), '-' End Do ! !******************************************************************************** ! Read TM !******************************************************************************** ! Call Read_TM ( Num_Mats_loc , Mat_Name_loc , TM_Mat_loc , 'ASC' ) ! print * , 'TM_Mat_loc allocated? : ' , Allocated ( TM_Mat_loc ) Do i = 1 , Num_Mats_loc print * , 'p_read: TM_Mat_loc Name, Number, Density: ' print * , trim ( TM_Mat_loc ( i )% Name ), TM_Mat_loc ( i )% Num_Isotopes , TM_Mat_loc ( i )% Density print * , 'TM_Mat_loc(i)%A allocated? : ' , Allocated ( TM_Mat_loc ( i )% A_Target_Material ) print * , 'TM_Mat_loc(i)%Z allocated? : ' , Allocated ( TM_Mat_loc ( i )% Z_Target_Material ) print * , 'TM_Mat_loc(i)%D allocated? : ' , Allocated ( TM_Mat_loc ( i )% D_Target_Material ) Do j = 1 , TM_Mat_loc ( i )% Num_Isotopes print * , 'A: ' , TM_Mat_loc ( i )% A_Target_Material ( j ) print * , 'Z: ' , TM_Mat_loc ( i )% Z_Target_Material ( j ) print * , 'D: ' , TM_Mat_loc ( i )% D_Target_Material ( j ) End Do End Do ! !******************************************************************************** ! End of Program !******************************************************************************** ! End Program HZETRN_TRN","tags":"","loc":"program/hzetrn_trn.html","title":"HZETRN_TRN – quarantine"}]}